// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "openzeppelin-latest/contracts/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import {BaseAccount} from "account-abstraction/core/BaseAccount.sol";
import "account-abstraction/core/Helpers.sol";
import {IEntryPoint} from "account-abstraction/interfaces/IEntryPoint.sol";
import {UserOperation} from "account-abstraction/interfaces/UserOperation.sol";
import {TokenCallbackHandler} from "account-abstraction/samples/callback/TokenCallbackHandler.sol";
import {FrameVerifier} from "frame-verifier/FrameVerifier.sol";
import "frame-verifier/Encoder.sol";
import {InflateLib} from "inflate-sol/InflateLib.sol";

import {console} from "forge-std/console.sol";


contract FrameWallet is BaseAccount, TokenCallbackHandler, UUPSUpgradeable, Initializable {
    IEntryPoint private immutable _ENTRY_POINT;
    string public constant URL_PREFIX = "https://frame-wallet.vercel.app/v1/";

    // We identify Farcaster users by the Ed25519 public key they used to sign a FrameAction.
    // Users with several Farcaster keys will only be able to access a FrameWallet from the single key
    // that was used to create it.
    bytes32 public pk;

    // Typical 4337 wallets sign the entire userOp in their transactions, including the sender
    // address for the transaction. We can't include the sender address in our user-agnostic URLs,
    // which makes it harder to limit our signatures to one specific wallet. We store the salt
    // used to create the wallet, and it it's nonzero, we expect the salt to appear in the URL.
    uint256 public salt;

    // Each FrameAction has a timestamp within the payload that is generated by the user's
    // Farcaster client. We assume that these timestamps increase monotonically to enable
    // stateless Frame Wallet frames that can sign transaction data without first querying
    // the chain for a nonce.
    uint256 public lastFrameTimestamp;

    struct FrameUserOpSignature {
        MessageData md;
        bytes ed25519sig;
        bytes compressedPartialUserOp;
    }

    struct PartialUserOp {
      uint256 chainId;
      bytes callData;
      uint256 callGasLimit;
      uint256 verificationGasLimit;
      uint256 preVerificationGas;
      uint256 maxFeePerGas;
      uint256 maxPriorityFeePerGas;
    }

    constructor(IEntryPoint anEntryPoint) {
        _ENTRY_POINT = anEntryPoint;
        // Disable the initializer for the implementation contract.
        _disableInitializers();
    }

    event FrameWalletInitialized(IEntryPoint indexed entryPoint, bytes32 indexed pk, uint256 indexed salt);

    function initialize(bytes32 ownerPk, uint256 walletSalt) public virtual initializer {
        pk = ownerPk;
        salt = walletSalt;
        emit FrameWalletInitialized(_ENTRY_POINT, ownerPk, walletSalt);
    }

    function _puff(bytes calldata data, uint destlen) public returns (InflateLib.ErrorCode, bytes memory) {
        return InflateLib.puff(data, destlen);
    }

    /*
     * Implement template method of BaseAccount.
     */
    function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)
        internal
        virtual
        override
        returns (uint256 validationData)
    {
        // NOTE: Per EIP 4337, accounts MUST validate that the signature is a valid signature
        // of userOpHash, which includes the userOp, entryPoint, and chainId in the payload.
        // However, the userOp's calldata alone is too large to fit inside Farcaster's 256
        // character limit for URLs, so we deviate from the standard to sign less data
        // (which is insecure against replay and gas draining attacts) and to compress
        // the data before signing it.

        // userOp has a signature field intended for implementation-specific data, so we
        // use it to pass more than just the signature. We pass a FrameUserOpSignature that
        // includes the extra data we need to verify.
        FrameUserOpSignature memory frameSig = abi.decode(userOp.signature, (FrameUserOpSignature));

        // Decompress the provided compressed calldata and confirm that it matches what's directly in the userOp.
        (InflateLib.ErrorCode decompressErrorCode, bytes memory partialUserOpBytes) = this._puff(
            frameSig.compressedPartialUserOp,
            // A PartialUserOp is a tuple with six uint256 items plus the callData. A tuple begins
            // with a 32-byte word for its offset pointer. The calldata needs two 32-byte words
            // (one for offset, the other for length) plus its own length.
            // That should be enough to fit the decompressed data, but an error is thrown without
            // space for one more 32-byte word.
            (32) + (32 * 6) + ((32 * 2) + userOp.callData.length) + (32 * 1)
        );
        
        if (decompressErrorCode != InflateLib.ErrorCode.ERR_NONE) {
            console.log("Inflate failed with error code %s", uint256(decompressErrorCode));
            return SIG_VALIDATION_FAILED;
        }
        console.log("Inflate successful:");
        console.logBytes(partialUserOpBytes);

        PartialUserOp memory partialUserOp = abi.decode(partialUserOpBytes, (PartialUserOp));
        console.log("PartialUserOp decoded");

        if (partialUserOp.chainId != block.chainid ||
            keccak256(partialUserOp.callData) != keccak256(userOp.callData) ||
            partialUserOp.callGasLimit != userOp.callGasLimit ||
            partialUserOp.verificationGasLimit != userOp.verificationGasLimit ||
            partialUserOp.preVerificationGas != userOp.preVerificationGas ||
            partialUserOp.maxFeePerGas != userOp.maxFeePerGas ||
            partialUserOp.maxPriorityFeePerGas != userOp.maxPriorityFeePerGas
        ) {
            return SIG_VALIDATION_FAILED;
        }
        console.log("PartialUserOp matches UserOp");

        if (frameSig.md.timestamp <= lastFrameTimestamp) {
            return SIG_VALIDATION_FAILED;
        }
        lastFrameTimestamp = frameSig.md.timestamp;
        console.log("Timestamp check succeeded");
        
        // Ensure that frameUrl contains the compressed calldata so we know the user signed it.
        string memory saltParams = salt == 0 ? "" : string.concat("?s=", Strings.toString(salt));
        bytes memory expectedUrl = abi.encodePacked(
            URL_PREFIX,
            toHexString(frameSig.compressedPartialUserOp),
            saltParams
        );

        console.log("Expected frame URL: %s", string(expectedUrl));
        console.log("Actual frame URL: %s", string(frameSig.md.frame_action_body.url));
        if (!Strings.equal(string(frameSig.md.frame_action_body.url), string(expectedUrl))) {
            return SIG_VALIDATION_FAILED;
        }
        console.log("Frame URL contents match expected URL");

        (bytes32 r, bytes32 s) = abi.decode(frameSig.ed25519sig, (bytes32, bytes32));
        if (FrameVerifier.verifyMessageData(pk, r, s, frameSig.md)) {
            return 0; // SIG_VALIDATION_SUCCESS
        } else {
            return SIG_VALIDATION_FAILED;
        }
    }

    function substring(bytes memory source, uint256 length) internal returns (bytes memory) {
        bytes memory destination = new bytes(length);
        for (uint i = 0; i < length; i++) {
            destination[i] = source[i];
        }
        return destination;
    }

    bytes16 private constant HEX_DIGITS = "0123456789abcdef";

    function toHexString(bytes memory value) internal pure returns (string memory) {
        bytes memory buffer = new bytes(2 * value.length);
        for (uint256 byteIndex = 0; byteIndex < value.length; byteIndex++) {
            uint256 hexIndex = byteIndex * 2;
            buffer[hexIndex] = HEX_DIGITS[uint8(value[byteIndex]) >> 4];
            hexIndex++;
            buffer[hexIndex] = HEX_DIGITS[uint8(value[byteIndex]) & 0xf];
        }
        return string(buffer);
    }

    /**
     * execute a transaction (called directly from owner, or by entryPoint)
     * @param dest destination address to call
     * @param value the value to pass in this call
     * @param func the calldata to pass in this call
     */
    function execute(address dest, uint256 value, bytes calldata func) external {
        _requireFromEntryPoint();
        _call(dest, value, func);
    }

    /**
     * execute a sequence of transactions
     * @dev to reduce gas consumption for trivial case (no value), use a zero-length array to mean zero value
     * @param dest an array of destination addresses
     * @param value an array of values to pass to each call. can be zero-length for no-value calls
     * @param func an array of calldata to pass to each call
     */
    function executeBatch(address[] calldata dest, uint256[] calldata value, bytes[] calldata func) external {
        _requireFromEntryPoint();
        require(dest.length == func.length && (value.length == 0 || value.length == func.length), "wrong array lengths");
        if (value.length == 0) {
            for (uint256 i = 0; i < dest.length; i++) {
                _call(dest[i], 0, func[i]);
            }
        } else {
            for (uint256 i = 0; i < dest.length; i++) {
                _call(dest[i], value[i], func[i]);
            }
        }
    }

    function _call(address target, uint256 value, bytes memory data) internal {
        (bool success, bytes memory result) = target.call{value: value}(data);
        if (!success) {
            assembly {
                revert(add(result, 32), mload(result))
            }
        }
    }

    error NotAuthorized(address caller);

    function _authorizeUpgrade(address newImplementation) internal view override {
        (newImplementation);
        if (msg.sender != address(entryPoint())) {
            revert NotAuthorized(msg.sender);
        }
    }

    function entryPoint() public view virtual override returns (IEntryPoint) {
        return _ENTRY_POINT;
    }

    /**
     * Require a sequential nonce.
     *
     * The entry point enforces that the lower 64 bits of the nonce are sequential for
     * any given "key," the upper 192 bits of the nonce. Rejecting any nonces that use
     * any of the upper 192 bits is required to enforce sequential nonces.
     */
    function _validateNonce(uint256 nonce) override internal view virtual {
        require(nonce < type(uint64).max);
    }
}
